####################################################################################
'''
Использование модуля pynput.keyboard библиотеки pynput в Python.
Модуль pynput.keyboard библиотеки pynput содержит классы для управления и мониторинга клавиатуры.
'''
####################################################################################
'''
Управление клавиатурой.
Для управления клавиатурой используйте класс keyboard.Controller следующим образом:
'''
print('--------pynput.keyboard import Key, Controller---------')
from pynput.keyboard import Key, Controller

keyboard = Controller()

# Нажимает и отпускает клавишу пробела
print('-1----------------')
keyboard.press(Key.space)
keyboard.release(Key.space)
print('\n-1----------------')

# печатает строчную букву `a`, будет работать, даже если ни 
# одна клавиша на физической клавиатуре не помечена буквой `a`.
print('-2----------------')
keyboard.press('a')
keyboard.release('a')
print('\n-2----------------')

# печатает две заглавные буквы `A`:
# выводим сразу заглавную 'A'
print('-3----------------')
keyboard.press('A')
keyboard.release('A')
# выводим заглавную 'A' через нажатие `Key.shift`
with keyboard.pressed(Key.shift):
    keyboard.press('a')
    keyboard.release('a')
print('\n-3----------------')

# печатает 'Hello World', используя метод быстрого ввода
print('-4----------------')
keyboard.type('Hello World')
print('\n-4----------------')

# вывод
'''
red@red:~/WORK/PYTHON/MyPROG/Python.Example$ python pynput.keyboard.py
-1----------------

-1----------------
-2----------------
 a
-2----------------
-3----------------
AA
-3----------------
-4----------------
Hello World
-4----------------
red@red:~/WORK/PYTHON/MyPROG/Python.Example$ aAAHello World
'''
####################################################################################
'''
Мониторинг клавиатуры.
Для мониторинга клавиатуры используйте класс keyboard.Listener следующим образом:
'''
print('--------from pynput import keyboard---------')
from pynput import keyboard

def on_press(key):
    try:
        print(f'Нажата буквенно-цифровая клавиша: {key.char}')
    except AttributeError:
        print(f'Нажата специальная клавиша: {key}')

def on_release(key):
    print(f'{key} released')
    if key == keyboard.Key.esc:
        # Возврат False - остановит слушатель
        return False

# блок `with` слушает события до выхода 
# до остановки слушателя
with keyboard.Listener(
        on_press=on_press,
        on_release=on_release
        ) as listener:
    listener.join()

# #...или неблокирующим способом:
# listener = keyboard.Listener(
#     on_press=on_press,
#     on_release=on_release
# )
# listener.start()
'''
Слушатель клавиатуры keyboard.Listener - это threading.Thread, 
и все обратные вызовы будут вызываться из потока.

Чтобы остановить слушатель клавиатуры, можно вызвать keyboard.Listener.stop() 
из любого места, что в свою очередь вызовет исключение StopException 
или возвратить False из функции обратного вызова.

Аргумент key, который передается слушателем в обратные вызовы, является keyboard.Key 
для специальных клавиш и keyboard.KeyCode для обычных буквенно-цифровых клавиш 
или просто None для неизвестных клавиш.

При использовании приведенной выше неблокирующей версии текущий поток продолжит 
выполнение. Это может быть необходимо при интеграции с другими платформами 
графического интерфейса, включающими основной цикл, но при запуске из скрипта 
это приведет к немедленному завершению программы.
'''
####################################################################################
'''
Поток слушателя клавиатуры keyboard.Listener.

Обратные вызовы слушателя keyboard.Listener, на некоторых платформах, 
особенно в Windows, вызываются непосредственно из рабочего потока. 
Это означает, что длительно выполняющиеся процедуры и блокирующие операции 
не должны вызываться из обратного вызова, так как это может привести 
к зависанию ввода для всех процессов.

Возможный обходной путь - это просто отправить входящие события в очередь 
и позволить отдельному потоку обрабатывать их.
'''
####################################################################################
'''
Обработка ошибок слушателя клавиатуры.

Если обработчик обратного вызова вызывает исключение, то слушатель будет остановлен. 
Поскольку обратные вызовы выполняются в выделенном потоке, исключения не будут 
автоматически повторно вызываться.

Чтобы получать уведомления об ошибках обратного вызова, необходимо вызвать 
Thread.join() для экземпляра слушателя keyboard.Listener:
'''
print('--------Exception---------')
from pynput import keyboard

class MyException(Exception): pass

def on_press(key):
    if key == keyboard.Key.esc:
        raise MyException(key)

# блок `with` слушает события до выхода
with keyboard.Listener(
        on_press=on_press
        ) as listener:
    try:
        listener.join()
    except MyException as e:
        print(f'{e.args[0]}')
####################################################################################
'''
Переключение прослушивания событий для клавиатуры.

После вызова keyboard.Listener.stop() слушатель не может быть перезапущен, 
так как слушатели keyboard.Listener являются экземплярами threading.Thread.

Если приложение требует переключения событий keyboard.Listener, 
то необходимо либо добавить внутренний флаг для игнорирования событий, 
когда они не требуются, либо создать новый слушатель keyboard.Listener 
для возобновления прослушивания.
'''
####################################################################################
'''
Синхронное прослушивание событий для клавиатуры.

Для упрощения написания сценариев с синхронным прослушиванием событий поддерживается 
служебный класс keyboard.Events. Этот класс поддерживает чтение отдельных событий 
неблокирующим способом, а также повторение всех событий.
'''
# Чтобы прочитать одно событие, используйте следующий код:
print('--------Events---------')
from pynput import keyboard

# В блоке `with` будет работать слушатель событий.
with keyboard.Events() as events:
    # Блокировать не более одной секунды
    event = events.get(1.0)
    if event is None:
        print('Вы не нажали клавишу в течение одной секунды')
    else:
        print('Получено событие {event}')

# Чтобы перебрать события клавиатуры, используйте следующий код:
print('--------event in events---------')
from pynput import keyboard

# В блоке `with` будет работать слушатель событий.
with keyboard.Events() as events:
    for event in events:
        if event.key == keyboard.Key.esc:
            # выход из слушателя
            break
        else:
            # print('Получено событие {event}')
            print(f'Получено событие {event.key}')

'''
Обратите внимание, что контекстный менеджер with не поддерживает неблокирующую операцию, 
поэтому он будет ожидать хотя бы одно событие клавиатуры.

События будут экземплярами внутренних классов, найденных в keyboard.Events.
'''
####################################################################################
'''
Прослушивание глобальных горячих клавиш.

Обычный вариант использования клавиатурных мониторов - реакция на глобальные горячие клавиши. 
Так как слушатель не поддерживает никакого состояния, то горячие клавиши, 
использующие сочетания несколько клавиш, должны где-то хранить это состояние.

Для этой цели модуль pynput предоставляет класс keyboard.HotKey. 
Он содержит два метода для обновления состояния, предназначенных для простого взаимодействия 
со слушателем клавиатуры: keyboard.HotKey.press и keyboard.HotKey.release, 
которые можно напрямую передавать в качестве обратных вызовов слушателя.
'''
# Предполагаемое использование выглядит следующим образом:
print('--------keyboard.HotKey---------')
from pynput import keyboard

def on_activate():
    print('Активирована глобальная горячая клавиша!')
    # для выхода
    raise Exception

def for_canonical(f):
    return lambda k: f(l.canonical(k))

# определение горячей клавиши
hotkey = keyboard.HotKey(
    keyboard.HotKey.parse('<ctrl>+<alt>+h'),
    on_activate
    )

with keyboard.Listener(
        on_press=for_canonical(hotkey.press),
        on_release=for_canonical(hotkey.release)
        ) as l:
    try:
        l.join()
    except Exception as e:
        pass

'''
Представленный код создаст горячую клавишу, а затем использует слушатель 
для обновления ее состояния. Как только все указанные клавиши одновременно будут нажаты, 
будет вызвана функция on_activate().

Обратите внимание, что ключи передаются через keyboard.Listener.canonical перед 
передачей экземпляру keyboard.HotKey. Это делается для того, чтобы удалить любое 
состояние модификатора из ключевых событий и нормализовать модификаторы с более чем 
одной физической клавишей.

Метод keyboard.HotKey.parse - это удобная функция для преобразования строк быстрого 
доступа в наборы ключей. для получения дополнительной информации, смотрите его 
документацию keyboard.HotKey.

Чтобы зарегистрировать несколько глобальных горячих клавиш, используйте 
вспомогательный класс keyboard.GlobalHotKeys:
'''
print('--------keyboard.GlobalHotKeys---------')
from pynput import keyboard

def on_activate_h():
    print('Нажато сочетание клавиш: <ctrl>+<alt>+h')

def on_activate_i():
    print('Нажато сочетание клавиш: <ctrl>+<alt>+i')

def on_activate_e():
        print('Нажато сочетание клавиш: <ctrl>+<alt>+e')
        # для выхода из программы
        raise Exception

with keyboard.GlobalHotKeys({
        '<ctrl>+<alt>+h': on_activate_h,
        '<ctrl>+<alt>+i': on_activate_i,
        '<ctrl>+<alt>+e': on_activate_e}
        ) as h:
    try:
        h.join()
    except Exception as e:
        pass
####################################################################################